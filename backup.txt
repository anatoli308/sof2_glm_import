
GetMaterial!!
f, name, bsShader, shader_def: str = ""):
        """
        Lädt ein Material basierend auf dem G2/G3 Shader.
        shader_def: optionaler Text der Shader-Definition (.shader) - hilft, map-Einträge zu finden.
        Versucht, BaseColor, Normal, Roughness, Metallic, AO, Emission automatisch zu finden.
        """
        assert self.initialized

        shader = SoF2Stringhelper.decode(bsShader)
        if self.useSkin and shader in self.skin:
            shader = self.skin[shader]

        if shader is None:
            return None

        if shader.lower() in ["[nomaterial]", "", "*off"]:
            return None

        key = shader.lower()
        if key in self.materials:
            return self.materials[key]

        # Neues Material erstellen
        mat = bpy.data.materials.new(shader)
        self.materials[key] = mat

        # Hilfsfunktionen
        def _try_find_file(name_candidate: str):
            # wrapper für SoF2Filesystem.FindFile: returns (success, abs_path) or (False, "")
            if not name_candidate:
                return False, ""
            # if candidate contains extension already, FindFile should still work; try as-is
            return SoF2Filesystem.FindFile(name_candidate, self.basepath, ["jpg", "png", "tga", "dds"])

        def _find_sidecar_images(base_path_abs: str):
            """
            Given an absolute path to the basecolor image, look for common sidecar texture files
            in same directory sharing the basename + suffix.
            Returns dict of possible maps: normal, roughness, metallic, ao, emission
            """
            res = {"normal": None, "roughness": None, "metallic": None, "ao": None, "emission": None}
            if not base_path_abs or not os.path.isfile(base_path_abs):
                return res
            folder = os.path.dirname(base_path_abs)
            base = os.path.splitext(os.path.basename(base_path_abs))[0]
            exts = [".png", ".tga", ".jpg", ".dds"]
            suffixes = {
                "normal": ["_n", "_normal", "_norm", "_nrml", "_normalmap", "_bump"],
                "roughness": ["_r", "_rough", "_roughness"],
                "metallic": ["_m", "_metal", "_metallic"],
                "ao": ["_ao", "_ambientocclusion"],
                "emission": ["_emit", "_emiss", "_emission"]
            }
            for typ, suffs in suffixes.items():
                for s in suffs:
                    for ext in exts:
                        cand = os.path.join(folder, base + s + ext)
                        if os.path.isfile(cand):
                            res[typ] = cand
                            break
                    if res[typ]:
                        break
            return res

        # 1) Versuche Shader-Definition (raw text) zu parsen und erste 'map' zu verwenden
        base_texture_path = None
        if shader_def and isinstance(shader_def, str):
            # suche map tokens wie: map textures/foo/bar
            m = re.search(r'\bmap\s+([^\s\{\n]+)', shader_def)
            if m:
                candidate = m.group(1).strip().strip('"')
                success, abs_path = _try_find_file(candidate)
                if success:
                    base_texture_path = abs_path
                else:
                    # try candidate as relative path under basepath (FindFile might already resolve)
                    # leave for later fallback
                    base_texture_path = None

        # 2) Wenn kein shader_def-map, versuche shader direkt als texture-name zu finden (wie vorher)
        if not base_texture_path:
            success, abs_path = _try_find_file(shader)
            if success:
                base_texture_path = abs_path

        # 3) Wenn immer noch nichts gefunden -> Fallback (no texture)
        if not base_texture_path:
            print(f"Texture not found: {shader}")
            mat.diffuse_color = (1, 0, 1, 1)  # Pink fallback
            return mat

        # 4) Suche Sidecar maps (normal, roughness, metallic, ao, emission)
        sidecars = _find_sidecar_images(base_texture_path)

        # 5) Node-Setup: Principled BSDF
        mat.use_nodes = True
        nodes = mat.node_tree.nodes
        links = mat.node_tree.links

        # clear existing nodes
        for node in nodes:
            nodes.remove(node)

        output_node = nodes.new(type='ShaderNodeOutputMaterial')
        output_node.location = (400, 0)

        principled = nodes.new(type='ShaderNodeBsdfPrincipled')
        principled.location = (0, 0)

        # helper to create image texture node
        def _create_image_node(abs_path: str, label: str, colorspace: str = 'Non-Color', location=( -600, 0 )):
            try:
                img = bpy.data.images.load(abs_path, check_existing=True)
            except Exception as e:
                if log_level == "DEBUG":
                    print(f"Could not load image {abs_path}: {e}")
                return None
            tex = nodes.new(type='ShaderNodeTexImage')
            tex.image = img
            tex.label = label
            tex.location = location
            # set colorspace
            try:
                tex.image.colorspace_settings.name = colorspace
            except Exception:
                pass
            return tex

        # BASE COLOR (sRGB)
        base_tex_node = _create_image_node(base_texture_path, "BaseColor", colorspace='sRGB', location=(-600, 300))
        if base_tex_node:
            links.new(base_tex_node.outputs['Color'], principled.inputs['Base Color'])

        # NORMAL
        normal_node = None
        if sidecars.get("normal"):
            n_tex = _create_image_node(sidecars["normal"], "Normal", colorspace='Non-Color', location=(-600, 0))
            if n_tex:
                normal_map = nodes.new(type='ShaderNodeNormalMap')
                normal_map.location = (-300, 0)
                links.new(n_tex.outputs['Color'], normal_map.inputs['Color'])
                links.new(normal_map.outputs['Normal'], principled.inputs['Normal'])
                normal_node = n_tex

        # ROUGHNESS
        if sidecars.get("roughness"):
            r_tex = _create_image_node(sidecars["roughness"], "Roughness", colorspace='Non-Color', location=(-600, -150))
            if r_tex:
                links.new(r_tex.outputs['Color'], principled.inputs['Roughness'])

        # METALLIC
        if sidecars.get("metallic"):
            m_tex = _create_image_node(sidecars["metallic"], "Metallic", colorspace='Non-Color', location=(-600, -300))
            if m_tex:
                links.new(m_tex.outputs['Color'], principled.inputs['Metallic'])

        # AO -> multiply with base color (if both present)
        if sidecars.get("ao") and base_tex_node:
            ao_tex = _create_image_node(sidecars["ao"], "AO", colorspace='Non-Color', location=(-600, 450))
            if ao_tex:
                mix = nodes.new(type='ShaderNodeMixRGB')
                mix.blend_type = 'MULTIPLY'
                mix.inputs['Fac'].default_value = 1.0
                mix.location = (-300, 250)
                # connect base -> mix Color1, AO -> Color2
                links.new(base_tex_node.outputs['Color'], mix.inputs['Color1'])
                links.new(ao_tex.outputs['Color'], mix.inputs['Color2'])
                links.new(mix.outputs['Color'], principled.inputs['Base Color'])

        # EMISSION (optional)
        if sidecars.get("emission"):
            e_tex = _create_image_node(sidecars["emission"], "Emission", colorspace='sRGB', location=(-600, 600))
            if e_tex:
                emit_node = nodes.new(type='ShaderNodeEmission')
                emit_node.location = (-300, 600)
                links.new(e_tex.outputs['Color'], emit_node.inputs['Color'])
                # combine emission and principled via Add Shader
                add = nodes.new(type='ShaderNodeAddShader')
                add.location = (200, 100)
                links.new(principled.outputs['BSDF'], add.inputs[0])
                links.new(emit_node.outputs['Emission'], add.inputs[1])
                links.new(add.outputs['Shader'], output_node.inputs['Surface'])
        else:
            # standard connection
            links.new(principled.outputs['BSDF'], output_node.inputs['Surface'])

        # done
        return mat




______________________


def saveToBlender(self, skeleton: MdxaSkel, armature: bpy.types.Object, scale):
        import time

        startTime = time.time()
        print("Starting optimized animation import...")
        
        #   Bone Position Set Order (unchanged)
        hierarchyOrder: List[int] = []
        while len(hierarchyOrder) < len(skeleton.bones):
            addedSomething = False
            for bone in skeleton.bones:
                if bone.index in hierarchyOrder:
                    continue
                if bone.parent != -1 and bone.parent not in hierarchyOrder:
                    continue
                hierarchyOrder.append(bone.index)
                addedSomething = True
            assert addedSomething

        #   Blender PoseBones list (unchanged)
        bones: List[bpy.types.PoseBone] = []
        for info in skeleton.bones:
            bones.append(armature.pose.bones[info.name])

        basePoses: List[mathutils.Matrix] = []
        for bone in skeleton.bones:
            basePoses.append(bone.basePoseMat.toBlender())

        #   Prepare animation
        scene = bpy.context.scene
        scene.frame_start = 0
        numFrames = len(self.frames)
        scene.frame_end = numFrames - 1

        if scale == 0:
            scale = 1
        else:
            scale = 1 / scale

        # **OPTIMIZATION 1: Set mode once at the beginning**
        bpy.context.view_layer.objects.active = armature
        bpy.ops.object.mode_set(mode="POSE")
        print("Set to POSE mode - no more mode switching!")

        # **OPTIMIZATION 2: Create animation data directly**
        if not armature.animation_data:
            armature.animation_data_create()
        
        action = bpy.data.actions.new(name=f"{armature.name}_animation")
        armature.animation_data.action = action
        
        # **OPTIMIZATION 3: Pre-create all fcurves**
        print("Creating fcurves...")
        fcurves = {}
        for bone in bones:
            for prop in ["location", "rotation_quaternion"]:
                for i in range(3 if prop == "location" else 4):
                    fcurves[f"{bone.name}_{prop}_{i}"] = action.fcurves.new(
                        data_path=f'pose.bones["{bone.name}"].{prop}',
                        index=i
                    )

        # **OPTIMIZATION 4: Collect all keyframe data first**
        print("Processing transformations...")
        keyframe_data = {}
        for bone in bones:
            keyframe_data[bone.name] = {
                "location": [[] for _ in range(3)],
                "rotation_quaternion": [[] for _ in range(4)]
            }

        # Progress tracking
        nextProgressDisplayTime = time.time() + PROGRESS_UPDATE_INTERVAL
        lastFrameNum = 0

        # **OPTIMIZATION 5: Process all frames without mode switching or keyframe insertion**
        for frameNum, frame in enumerate(self.frames):
            # Progress display
            if time.time() >= nextProgressDisplayTime:
                numProcessedFrames = frameNum - lastFrameNum
                framesRemaining = numFrames - frameNum
                timeRemaining = (PROGRESS_UPDATE_INTERVAL * framesRemaining / numProcessedFrames)
                
                print(f"Frame {frameNum}/{numFrames} - {frameNum/numFrames:.2%} - remaining time: ca. {timeRemaining//60:.0f}m {timeRemaining%60:.0f}s")
                
                lastFrameNum = frameNum
                nextProgressDisplayTime = time.time() + PROGRESS_UPDATE_INTERVAL

            # **NO FRAME SETTING HERE - we'll do it in batches later**
            
            # Process bone transformations
            offsets: Dict[int, mathutils.Matrix] = {}
            for index in hierarchyOrder:
                # **NO MODE SWITCHING!**
                mdxaBone = skeleton.bones[index]
                assert mdxaBone.index == index
                bonePoolIndex = frame.boneIndices[index]
                
                # Get offset transformation matrix
                offset = downcast(List[SoF2G2Math.CompBone], self.bonePool.bones)[
                    bonePoolIndex
                ].matrix
                
                # Turn into absolute offset matrix
                if mdxaBone.parent != -1:
                    offset = matrix_overload_cast(offsets[mdxaBone.parent] @ offset)
                offsets[index] = offset
                
                # Calculate the actual position
                transformation = matrix_overload_cast(offset @ basePoses[index])
                SoF2G2Math.GLABoneRotToBlender(transformation)

                # **OPTIMIZATION 6: Store transformation data instead of applying immediately**
                pose_bone = bones[index]
                
                # Extract location and rotation from transformation matrix
                location = transformation.translation
                rotation = transformation.to_quaternion()
                
                # Store keyframe data
                bone_name = pose_bone.name
                keyframe_data[bone_name]["location"][0].append((frameNum, location.x))
                keyframe_data[bone_name]["location"][1].append((frameNum, location.y))
                keyframe_data[bone_name]["location"][2].append((frameNum, location.z))
                
                keyframe_data[bone_name]["rotation_quaternion"][0].append((frameNum, rotation.x))
                keyframe_data[bone_name]["rotation_quaternion"][1].append((frameNum, rotation.y))
                keyframe_data[bone_name]["rotation_quaternion"][2].append((frameNum, rotation.z))
                keyframe_data[bone_name]["rotation_quaternion"][3].append((frameNum, rotation.w))

        # **OPTIMIZATION 7: Batch insert all keyframes at once using keyframe_points.add()**
        print("Inserting keyframes...")
        total_keyframes = 0
        bone_count = 0
        total_bones = len(keyframe_data)
        
        for bone_name, bone_data in keyframe_data.items():
            bone_count += 1
            if bone_count % 10 == 0 or bone_count == total_bones:
                print(f"Processing bone {bone_count}/{total_bones}: {bone_name}")
            
            # Insert location keyframes
            for i in range(3):
                fcurve = fcurves[f"{bone_name}_location_{i}"]
                keyframe_data_list = bone_data["location"][i]
                if keyframe_data_list:  # Only if we have data
                    # Sort by frame number to ensure correct order
                    keyframe_data_list.sort(key=lambda x: x[0])
                    # Pre-allocate keyframe points
                    fcurve.keyframe_points.add(len(keyframe_data_list))
                    # Set all keyframes at once
                    for j, (frame_num, value) in enumerate(keyframe_data_list):
                        fcurve.keyframe_points[j].co = (frame_num, value)
                        fcurve.keyframe_points[j].interpolation = 'LINEAR'
                    total_keyframes += len(keyframe_data_list)
            
            # Insert rotation keyframes
            for i in range(4):
                fcurve = fcurves[f"{bone_name}_rotation_quaternion_{i}"]
                keyframe_data_list = bone_data["rotation_quaternion"][i]
                if keyframe_data_list:  # Only if we have data
                    # Sort by frame number to ensure correct order
                    keyframe_data_list.sort(key=lambda x: x[0])
                    # Pre-allocate keyframe points
                    fcurve.keyframe_points.add(len(keyframe_data_list))
                    # Set all keyframes at once
                    for j, (frame_num, value) in enumerate(keyframe_data_list):
                        fcurve.keyframe_points[j].co = (frame_num, value)
                        fcurve.keyframe_points[j].interpolation = 'LINEAR'
                    total_keyframes += len(keyframe_data_list)

        # **OPTIMIZATION 8: Update fcurves and set mode back**
        print("Updating fcurves...")
        for fcurve in action.fcurves:
            fcurve.update()
        
        bpy.ops.object.mode_set(mode="OBJECT")
        scene.frame_current = 1
        
        endTime = time.time()
        print(f"Animation import completed in {endTime - startTime:.2f} seconds")
        print(f"Inserted {total_keyframes} keyframes")
        print(f"Processed {numFrames} frames with {len(bones)} bones")