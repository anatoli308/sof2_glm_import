f, name, bsShader, shader_def: str = ""):
        """
        Lädt ein Material basierend auf dem G2/G3 Shader.
        shader_def: optionaler Text der Shader-Definition (.shader) - hilft, map-Einträge zu finden.
        Versucht, BaseColor, Normal, Roughness, Metallic, AO, Emission automatisch zu finden.
        """
        assert self.initialized

        shader = SoF2Stringhelper.decode(bsShader)
        if self.useSkin and shader in self.skin:
            shader = self.skin[shader]

        if shader is None:
            return None

        if shader.lower() in ["[nomaterial]", "", "*off"]:
            return None

        key = shader.lower()
        if key in self.materials:
            return self.materials[key]

        # Neues Material erstellen
        mat = bpy.data.materials.new(shader)
        self.materials[key] = mat

        # Hilfsfunktionen
        def _try_find_file(name_candidate: str):
            # wrapper für SoF2Filesystem.FindFile: returns (success, abs_path) or (False, "")
            if not name_candidate:
                return False, ""
            # if candidate contains extension already, FindFile should still work; try as-is
            return SoF2Filesystem.FindFile(name_candidate, self.basepath, ["jpg", "png", "tga", "dds"])

        def _find_sidecar_images(base_path_abs: str):
            """
            Given an absolute path to the basecolor image, look for common sidecar texture files
            in same directory sharing the basename + suffix.
            Returns dict of possible maps: normal, roughness, metallic, ao, emission
            """
            res = {"normal": None, "roughness": None, "metallic": None, "ao": None, "emission": None}
            if not base_path_abs or not os.path.isfile(base_path_abs):
                return res
            folder = os.path.dirname(base_path_abs)
            base = os.path.splitext(os.path.basename(base_path_abs))[0]
            exts = [".png", ".tga", ".jpg", ".dds"]
            suffixes = {
                "normal": ["_n", "_normal", "_norm", "_nrml", "_normalmap", "_bump"],
                "roughness": ["_r", "_rough", "_roughness"],
                "metallic": ["_m", "_metal", "_metallic"],
                "ao": ["_ao", "_ambientocclusion"],
                "emission": ["_emit", "_emiss", "_emission"]
            }
            for typ, suffs in suffixes.items():
                for s in suffs:
                    for ext in exts:
                        cand = os.path.join(folder, base + s + ext)
                        if os.path.isfile(cand):
                            res[typ] = cand
                            break
                    if res[typ]:
                        break
            return res

        # 1) Versuche Shader-Definition (raw text) zu parsen und erste 'map' zu verwenden
        base_texture_path = None
        if shader_def and isinstance(shader_def, str):
            # suche map tokens wie: map textures/foo/bar
            m = re.search(r'\bmap\s+([^\s\{\n]+)', shader_def)
            if m:
                candidate = m.group(1).strip().strip('"')
                success, abs_path = _try_find_file(candidate)
                if success:
                    base_texture_path = abs_path
                else:
                    # try candidate as relative path under basepath (FindFile might already resolve)
                    # leave for later fallback
                    base_texture_path = None

        # 2) Wenn kein shader_def-map, versuche shader direkt als texture-name zu finden (wie vorher)
        if not base_texture_path:
            success, abs_path = _try_find_file(shader)
            if success:
                base_texture_path = abs_path

        # 3) Wenn immer noch nichts gefunden -> Fallback (no texture)
        if not base_texture_path:
            print(f"Texture not found: {shader}")
            mat.diffuse_color = (1, 0, 1, 1)  # Pink fallback
            return mat

        # 4) Suche Sidecar maps (normal, roughness, metallic, ao, emission)
        sidecars = _find_sidecar_images(base_texture_path)

        # 5) Node-Setup: Principled BSDF
        mat.use_nodes = True
        nodes = mat.node_tree.nodes
        links = mat.node_tree.links

        # clear existing nodes
        for node in nodes:
            nodes.remove(node)

        output_node = nodes.new(type='ShaderNodeOutputMaterial')
        output_node.location = (400, 0)

        principled = nodes.new(type='ShaderNodeBsdfPrincipled')
        principled.location = (0, 0)

        # helper to create image texture node
        def _create_image_node(abs_path: str, label: str, colorspace: str = 'Non-Color', location=( -600, 0 )):
            try:
                img = bpy.data.images.load(abs_path, check_existing=True)
            except Exception as e:
                if log_level == "DEBUG":
                    print(f"Could not load image {abs_path}: {e}")
                return None
            tex = nodes.new(type='ShaderNodeTexImage')
            tex.image = img
            tex.label = label
            tex.location = location
            # set colorspace
            try:
                tex.image.colorspace_settings.name = colorspace
            except Exception:
                pass
            return tex

        # BASE COLOR (sRGB)
        base_tex_node = _create_image_node(base_texture_path, "BaseColor", colorspace='sRGB', location=(-600, 300))
        if base_tex_node:
            links.new(base_tex_node.outputs['Color'], principled.inputs['Base Color'])

        # NORMAL
        normal_node = None
        if sidecars.get("normal"):
            n_tex = _create_image_node(sidecars["normal"], "Normal", colorspace='Non-Color', location=(-600, 0))
            if n_tex:
                normal_map = nodes.new(type='ShaderNodeNormalMap')
                normal_map.location = (-300, 0)
                links.new(n_tex.outputs['Color'], normal_map.inputs['Color'])
                links.new(normal_map.outputs['Normal'], principled.inputs['Normal'])
                normal_node = n_tex

        # ROUGHNESS
        if sidecars.get("roughness"):
            r_tex = _create_image_node(sidecars["roughness"], "Roughness", colorspace='Non-Color', location=(-600, -150))
            if r_tex:
                links.new(r_tex.outputs['Color'], principled.inputs['Roughness'])

        # METALLIC
        if sidecars.get("metallic"):
            m_tex = _create_image_node(sidecars["metallic"], "Metallic", colorspace='Non-Color', location=(-600, -300))
            if m_tex:
                links.new(m_tex.outputs['Color'], principled.inputs['Metallic'])

        # AO -> multiply with base color (if both present)
        if sidecars.get("ao") and base_tex_node:
            ao_tex = _create_image_node(sidecars["ao"], "AO", colorspace='Non-Color', location=(-600, 450))
            if ao_tex:
                mix = nodes.new(type='ShaderNodeMixRGB')
                mix.blend_type = 'MULTIPLY'
                mix.inputs['Fac'].default_value = 1.0
                mix.location = (-300, 250)
                # connect base -> mix Color1, AO -> Color2
                links.new(base_tex_node.outputs['Color'], mix.inputs['Color1'])
                links.new(ao_tex.outputs['Color'], mix.inputs['Color2'])
                links.new(mix.outputs['Color'], principled.inputs['Base Color'])

        # EMISSION (optional)
        if sidecars.get("emission"):
            e_tex = _create_image_node(sidecars["emission"], "Emission", colorspace='sRGB', location=(-600, 600))
            if e_tex:
                emit_node = nodes.new(type='ShaderNodeEmission')
                emit_node.location = (-300, 600)
                links.new(e_tex.outputs['Color'], emit_node.inputs['Color'])
                # combine emission and principled via Add Shader
                add = nodes.new(type='ShaderNodeAddShader')
                add.location = (200, 100)
                links.new(principled.outputs['BSDF'], add.inputs[0])
                links.new(emit_node.outputs['Emission'], add.inputs[1])
                links.new(add.outputs['Shader'], output_node.inputs['Surface'])
        else:
            # standard connection
            links.new(principled.outputs['BSDF'], output_node.inputs['Surface'])

        # done
        return mat


